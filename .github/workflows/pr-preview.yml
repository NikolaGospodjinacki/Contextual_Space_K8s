# =============================================================================
# PR Preview Environment Workflow
# =============================================================================
# Deploys a preview environment for each pull request to EKS
# =============================================================================

name: PR Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]

# Cancel any in-progress runs for the same PR
concurrency:
  group: pr-preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
  ECR_FRONTEND_REPO: ${{ secrets.ECR_FRONTEND_REPO }}
  ECR_BACKEND_REPO: ${{ secrets.ECR_BACKEND_REPO }}
  PR_NUMBER: ${{ github.event.pull_request.number }}

permissions:
  id-token: write   # Required for OIDC
  contents: read
  pull-requests: write

jobs:
  deploy-preview:
    name: Deploy PR Preview
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-pr-${{ env.PR_NUMBER }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/frontend
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ env.ECR_FRONTEND_REPO }}:pr-${{ env.PR_NUMBER }}
          build-args: |
            VITE_BASE_PATH=/pr-${{ env.PR_NUMBER }}/
            VITE_SOCKET_URL=
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/backend
          file: ./apps/backend/Dockerfile
          push: true
          tags: ${{ env.ECR_BACKEND_REPO }}:pr-${{ env.PR_NUMBER }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Create namespace
        run: |
          kubectl create namespace pr-${{ env.PR_NUMBER }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to EKS
        run: |
          # Create ConfigMap
          cat <<EOF | kubectl apply -n pr-${{ env.PR_NUMBER }} -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: app-config
          data:
            BASE_PATH: "/pr-${{ env.PR_NUMBER }}/"
            NODE_ENV: "production"
          EOF

          # Deploy Backend
          cat <<EOF | kubectl apply -n pr-${{ env.PR_NUMBER }} -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backend
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: backend
            template:
              metadata:
                labels:
                  app: backend
              spec:
                containers:
                  - name: backend
                    image: ${{ env.ECR_BACKEND_REPO }}:pr-${{ env.PR_NUMBER }}
                    ports:
                      - containerPort: 3001
                    envFrom:
                      - configMapRef:
                          name: app-config
                    env:
                      - name: PORT
                        value: "3001"
                    resources:
                      requests:
                        memory: "128Mi"
                        cpu: "100m"
                      limits:
                        memory: "256Mi"
                        cpu: "200m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: backend
          spec:
            selector:
              app: backend
            ports:
              - port: 3001
                targetPort: 3001
          EOF

          # Deploy Frontend
          cat <<EOF | kubectl apply -n pr-${{ env.PR_NUMBER }} -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: frontend
            template:
              metadata:
                labels:
                  app: frontend
              spec:
                containers:
                  - name: frontend
                    image: ${{ env.ECR_FRONTEND_REPO }}:pr-${{ env.PR_NUMBER }}
                    ports:
                      - containerPort: 8080
                    resources:
                      requests:
                        memory: "64Mi"
                        cpu: "50m"
                      limits:
                        memory: "128Mi"
                        cpu: "100m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: frontend
          spec:
            selector:
              app: frontend
            ports:
              - port: 80
                targetPort: 8080
          EOF

          # Deploy Ingress
          cat <<EOF | kubectl apply -n pr-${{ env.PR_NUMBER }} -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: contextual-space
            annotations:
              nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
              nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
              nginx.ingress.kubernetes.io/use-regex: "true"
              nginx.ingress.kubernetes.io/rewrite-target: /\$2
              nginx.ingress.kubernetes.io/websocket-services: "backend"
              nginx.ingress.kubernetes.io/affinity: "cookie"
              nginx.ingress.kubernetes.io/session-cookie-name: "SERVERID"
              nginx.ingress.kubernetes.io/session-cookie-path: "/pr-${{ env.PR_NUMBER }}/socket.io"
          spec:
            ingressClassName: nginx
            rules:
              - http:
                  paths:
                    - path: /pr-${{ env.PR_NUMBER }}/socket.io(/|$)(.*)
                      pathType: ImplementationSpecific
                      backend:
                        service:
                          name: backend
                          port:
                            number: 3001
                    - path: /pr-${{ env.PR_NUMBER }}/health
                      pathType: Exact
                      backend:
                        service:
                          name: backend
                          port:
                            number: 3001
                    - path: /pr-${{ env.PR_NUMBER }}(/|$)(.*)
                      pathType: ImplementationSpecific
                      backend:
                        service:
                          name: frontend
                          port:
                            number: 80
          EOF

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/frontend -n pr-${{ env.PR_NUMBER }} --timeout=120s
          kubectl rollout status deployment/backend -n pr-${{ env.PR_NUMBER }} --timeout=120s

      - name: Get Preview URL
        id: preview-url
        run: |
          INGRESS_HOST=$(kubectl get ingress -n pr-${{ env.PR_NUMBER }} contextual-space -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -z "$INGRESS_HOST" ]; then
            INGRESS_HOST=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          fi
          PREVIEW_URL="http://${INGRESS_HOST}/pr-${{ env.PR_NUMBER }}/"
          echo "url=$PREVIEW_URL" >> $GITHUB_OUTPUT
          echo "üöÄ Preview URL: $PREVIEW_URL"

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.preview-url.outputs.url }}';
            const body = `## üöÄ Preview Environment Ready!
            
            Your preview environment has been deployed:
            
            üîó **Preview URL:** ${url}
            
            | Component | Status |
            |-----------|--------|
            | Frontend | ‚úÖ Deployed |
            | Backend | ‚úÖ Deployed |
            | WebSocket | ‚úÖ Connected |
            
            > ‚è±Ô∏è This preview will be automatically cleaned up when the PR is closed.
            
            ---
            <details>
            <summary>üìã Deployment Details</summary>
            
            - **Namespace:** pr-${{ env.PR_NUMBER }}
            - **Frontend Image:** \`${{ env.ECR_FRONTEND_REPO }}:pr-${{ env.PR_NUMBER }}\`
            - **Backend Image:** \`${{ env.ECR_BACKEND_REPO }}:pr-${{ env.PR_NUMBER }}\`
            - **Commit:** ${{ github.event.pull_request.head.sha }}
            
            </details>`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Preview Environment')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
